package main

import (
	"fmt"
	"reflect"
	"sort"

	"github.com/jacobsa/oglematchers"
)

// AUTO GENERATED - DO NOT EDIT
// GENERATED BY tools/genutil/gen_util.go

type IntS []int

func (a IntS) Val() []int {
	return a
}

func (a IntS) Copy() IntS {
	b := make(IntS, len(a))
	copy(b, a)
	return b
}

func (a IntS) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = 0
	}
	a = a[:len(a)-j+i]
}

func (a IntS) Insert(i int, x int) { a = append(a[:i], append([]int{x}, a[i:]...)...) }
func (a IntS) Delete(i int)        { a = append(a[:i], a[i+1:]...) }
func (a IntS) Push(x int)          { a = append(a, x) }
func (a IntS) Append(x ...int)     { a = append(a, x...) }
func (a IntS) Pop() int {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a IntS) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a IntS) Filter(f func(i int, value interface{}) bool) IntS {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a IntS) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a IntS) Map(f func(i int, value interface{}) int) IntS {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a IntS) Partition(f func(i int, value interface{}) bool) (IntS, IntS) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a IntS) EqualTo(b []int) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a IntS) Contains(b ...int) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a IntS) Resemble(b []int) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a IntS) Any(b ...int) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a IntS) All(b int) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a IntS) Frequency(b int) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinIntSlice(a ...[]int) IntS {
	b := make(IntS, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a IntS) IndexOf(x int) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type Int8S []int8

func (a Int8S) Val() []int8 {
	return a
}

func (a Int8S) Copy() Int8S {
	b := make(Int8S, len(a))
	copy(b, a)
	return b
}

func (a Int8S) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = 0
	}
	a = a[:len(a)-j+i]
}

func (a Int8S) Insert(i int, x int8) { a = append(a[:i], append([]int8{x}, a[i:]...)...) }
func (a Int8S) Delete(i int)         { a = append(a[:i], a[i+1:]...) }
func (a Int8S) Push(x int8)          { a = append(a, x) }
func (a Int8S) Append(x ...int8)     { a = append(a, x...) }
func (a Int8S) Pop() int8 {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a Int8S) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a Int8S) Filter(f func(i int, value interface{}) bool) Int8S {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a Int8S) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a Int8S) Map(f func(i int, value interface{}) int8) Int8S {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a Int8S) Partition(f func(i int, value interface{}) bool) (Int8S, Int8S) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a Int8S) EqualTo(b []int8) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a Int8S) Contains(b ...int8) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a Int8S) Resemble(b []int8) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a Int8S) Any(b ...int8) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a Int8S) All(b int8) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a Int8S) Frequency(b int8) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinInt8Slice(a ...[]int8) Int8S {
	b := make(Int8S, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a Int8S) IndexOf(x int8) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type Int16S []int16

func (a Int16S) Val() []int16 {
	return a
}

func (a Int16S) Copy() Int16S {
	b := make(Int16S, len(a))
	copy(b, a)
	return b
}

func (a Int16S) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = 0
	}
	a = a[:len(a)-j+i]
}

func (a Int16S) Insert(i int, x int16) { a = append(a[:i], append([]int16{x}, a[i:]...)...) }
func (a Int16S) Delete(i int)          { a = append(a[:i], a[i+1:]...) }
func (a Int16S) Push(x int16)          { a = append(a, x) }
func (a Int16S) Append(x ...int16)     { a = append(a, x...) }
func (a Int16S) Pop() int16 {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a Int16S) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a Int16S) Filter(f func(i int, value interface{}) bool) Int16S {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a Int16S) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a Int16S) Map(f func(i int, value interface{}) int16) Int16S {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a Int16S) Partition(f func(i int, value interface{}) bool) (Int16S, Int16S) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a Int16S) EqualTo(b []int16) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a Int16S) Contains(b ...int16) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a Int16S) Resemble(b []int16) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a Int16S) Any(b ...int16) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a Int16S) All(b int16) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a Int16S) Frequency(b int16) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinInt16Slice(a ...[]int16) Int16S {
	b := make(Int16S, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a Int16S) IndexOf(x int16) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type Int32S []int32

func (a Int32S) Val() []int32 {
	return a
}

func (a Int32S) Copy() Int32S {
	b := make(Int32S, len(a))
	copy(b, a)
	return b
}

func (a Int32S) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = 0
	}
	a = a[:len(a)-j+i]
}

func (a Int32S) Insert(i int, x int32) { a = append(a[:i], append([]int32{x}, a[i:]...)...) }
func (a Int32S) Delete(i int)          { a = append(a[:i], a[i+1:]...) }
func (a Int32S) Push(x int32)          { a = append(a, x) }
func (a Int32S) Append(x ...int32)     { a = append(a, x...) }
func (a Int32S) Pop() int32 {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a Int32S) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a Int32S) Filter(f func(i int, value interface{}) bool) Int32S {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a Int32S) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a Int32S) Map(f func(i int, value interface{}) int32) Int32S {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a Int32S) Partition(f func(i int, value interface{}) bool) (Int32S, Int32S) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a Int32S) EqualTo(b []int32) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a Int32S) Contains(b ...int32) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a Int32S) Resemble(b []int32) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a Int32S) Any(b ...int32) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a Int32S) All(b int32) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a Int32S) Frequency(b int32) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinInt32Slice(a ...[]int32) Int32S {
	b := make(Int32S, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a Int32S) IndexOf(x int32) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type Int64S []int64

func (a Int64S) Val() []int64 {
	return a
}

func (a Int64S) Copy() Int64S {
	b := make(Int64S, len(a))
	copy(b, a)
	return b
}

func (a Int64S) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = 0
	}
	a = a[:len(a)-j+i]
}

func (a Int64S) Insert(i int, x int64) { a = append(a[:i], append([]int64{x}, a[i:]...)...) }
func (a Int64S) Delete(i int)          { a = append(a[:i], a[i+1:]...) }
func (a Int64S) Push(x int64)          { a = append(a, x) }
func (a Int64S) Append(x ...int64)     { a = append(a, x...) }
func (a Int64S) Pop() int64 {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a Int64S) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a Int64S) Filter(f func(i int, value interface{}) bool) Int64S {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a Int64S) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a Int64S) Map(f func(i int, value interface{}) int64) Int64S {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a Int64S) Partition(f func(i int, value interface{}) bool) (Int64S, Int64S) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a Int64S) EqualTo(b []int64) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a Int64S) Contains(b ...int64) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a Int64S) Resemble(b []int64) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a Int64S) Any(b ...int64) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a Int64S) All(b int64) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a Int64S) Frequency(b int64) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinInt64Slice(a ...[]int64) Int64S {
	b := make(Int64S, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a Int64S) IndexOf(x int64) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type Uint8S []uint8

func (a Uint8S) Val() []uint8 {
	return a
}

func (a Uint8S) Copy() Uint8S {
	b := make(Uint8S, len(a))
	copy(b, a)
	return b
}

func (a Uint8S) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = 0
	}
	a = a[:len(a)-j+i]
}

func (a Uint8S) Insert(i int, x uint8) { a = append(a[:i], append([]uint8{x}, a[i:]...)...) }
func (a Uint8S) Delete(i int)          { a = append(a[:i], a[i+1:]...) }
func (a Uint8S) Push(x uint8)          { a = append(a, x) }
func (a Uint8S) Append(x ...uint8)     { a = append(a, x...) }
func (a Uint8S) Pop() uint8 {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a Uint8S) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a Uint8S) Filter(f func(i int, value interface{}) bool) Uint8S {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a Uint8S) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a Uint8S) Map(f func(i int, value interface{}) uint8) Uint8S {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a Uint8S) Partition(f func(i int, value interface{}) bool) (Uint8S, Uint8S) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a Uint8S) EqualTo(b []uint8) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a Uint8S) Contains(b ...uint8) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a Uint8S) Resemble(b []uint8) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a Uint8S) Any(b ...uint8) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a Uint8S) All(b uint8) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a Uint8S) Frequency(b uint8) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinUint8Slice(a ...[]uint8) Uint8S {
	b := make(Uint8S, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a Uint8S) IndexOf(x uint8) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type Uint16S []uint16

func (a Uint16S) Val() []uint16 {
	return a
}

func (a Uint16S) Copy() Uint16S {
	b := make(Uint16S, len(a))
	copy(b, a)
	return b
}

func (a Uint16S) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = 0
	}
	a = a[:len(a)-j+i]
}

func (a Uint16S) Insert(i int, x uint16) { a = append(a[:i], append([]uint16{x}, a[i:]...)...) }
func (a Uint16S) Delete(i int)           { a = append(a[:i], a[i+1:]...) }
func (a Uint16S) Push(x uint16)          { a = append(a, x) }
func (a Uint16S) Append(x ...uint16)     { a = append(a, x...) }
func (a Uint16S) Pop() uint16 {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a Uint16S) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a Uint16S) Filter(f func(i int, value interface{}) bool) Uint16S {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a Uint16S) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a Uint16S) Map(f func(i int, value interface{}) uint16) Uint16S {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a Uint16S) Partition(f func(i int, value interface{}) bool) (Uint16S, Uint16S) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a Uint16S) EqualTo(b []uint16) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a Uint16S) Contains(b ...uint16) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a Uint16S) Resemble(b []uint16) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a Uint16S) Any(b ...uint16) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a Uint16S) All(b uint16) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a Uint16S) Frequency(b uint16) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinUint16Slice(a ...[]uint16) Uint16S {
	b := make(Uint16S, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a Uint16S) IndexOf(x uint16) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type Uint32S []uint32

func (a Uint32S) Val() []uint32 {
	return a
}

func (a Uint32S) Copy() Uint32S {
	b := make(Uint32S, len(a))
	copy(b, a)
	return b
}

func (a Uint32S) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = 0
	}
	a = a[:len(a)-j+i]
}

func (a Uint32S) Insert(i int, x uint32) { a = append(a[:i], append([]uint32{x}, a[i:]...)...) }
func (a Uint32S) Delete(i int)           { a = append(a[:i], a[i+1:]...) }
func (a Uint32S) Push(x uint32)          { a = append(a, x) }
func (a Uint32S) Append(x ...uint32)     { a = append(a, x...) }
func (a Uint32S) Pop() uint32 {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a Uint32S) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a Uint32S) Filter(f func(i int, value interface{}) bool) Uint32S {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a Uint32S) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a Uint32S) Map(f func(i int, value interface{}) uint32) Uint32S {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a Uint32S) Partition(f func(i int, value interface{}) bool) (Uint32S, Uint32S) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a Uint32S) EqualTo(b []uint32) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a Uint32S) Contains(b ...uint32) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a Uint32S) Resemble(b []uint32) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a Uint32S) Any(b ...uint32) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a Uint32S) All(b uint32) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a Uint32S) Frequency(b uint32) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinUint32Slice(a ...[]uint32) Uint32S {
	b := make(Uint32S, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a Uint32S) IndexOf(x uint32) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type Uint64S []uint64

func (a Uint64S) Val() []uint64 {
	return a
}

func (a Uint64S) Copy() Uint64S {
	b := make(Uint64S, len(a))
	copy(b, a)
	return b
}

func (a Uint64S) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = 0
	}
	a = a[:len(a)-j+i]
}

func (a Uint64S) Insert(i int, x uint64) { a = append(a[:i], append([]uint64{x}, a[i:]...)...) }
func (a Uint64S) Delete(i int)           { a = append(a[:i], a[i+1:]...) }
func (a Uint64S) Push(x uint64)          { a = append(a, x) }
func (a Uint64S) Append(x ...uint64)     { a = append(a, x...) }
func (a Uint64S) Pop() uint64 {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a Uint64S) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a Uint64S) Filter(f func(i int, value interface{}) bool) Uint64S {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a Uint64S) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a Uint64S) Map(f func(i int, value interface{}) uint64) Uint64S {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a Uint64S) Partition(f func(i int, value interface{}) bool) (Uint64S, Uint64S) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a Uint64S) EqualTo(b []uint64) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a Uint64S) Contains(b ...uint64) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a Uint64S) Resemble(b []uint64) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a Uint64S) Any(b ...uint64) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a Uint64S) All(b uint64) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a Uint64S) Frequency(b uint64) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinUint64Slice(a ...[]uint64) Uint64S {
	b := make(Uint64S, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a Uint64S) IndexOf(x uint64) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type Float32S []float32

func (a Float32S) Val() []float32 {
	return a
}

func (a Float32S) Copy() Float32S {
	b := make(Float32S, len(a))
	copy(b, a)
	return b
}

func (a Float32S) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = 0.0
	}
	a = a[:len(a)-j+i]
}

func (a Float32S) Insert(i int, x float32) { a = append(a[:i], append([]float32{x}, a[i:]...)...) }
func (a Float32S) Delete(i int)            { a = append(a[:i], a[i+1:]...) }
func (a Float32S) Push(x float32)          { a = append(a, x) }
func (a Float32S) Append(x ...float32)     { a = append(a, x...) }
func (a Float32S) Pop() float32 {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a Float32S) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a Float32S) Filter(f func(i int, value interface{}) bool) Float32S {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a Float32S) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a Float32S) Map(f func(i int, value interface{}) float32) Float32S {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a Float32S) Partition(f func(i int, value interface{}) bool) (Float32S, Float32S) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a Float32S) EqualTo(b []float32) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a Float32S) Contains(b ...float32) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a Float32S) Resemble(b []float32) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a Float32S) Any(b ...float32) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a Float32S) All(b float32) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a Float32S) Frequency(b float32) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinFloat32Slice(a ...[]float32) Float32S {
	b := make(Float32S, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a Float32S) IndexOf(x float32) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type Float64S []float64

func (a Float64S) Val() []float64 {
	return a
}

func (a Float64S) Copy() Float64S {
	b := make(Float64S, len(a))
	copy(b, a)
	return b
}

func (a Float64S) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = 0.0
	}
	a = a[:len(a)-j+i]
}

func (a Float64S) Insert(i int, x float64) { a = append(a[:i], append([]float64{x}, a[i:]...)...) }
func (a Float64S) Delete(i int)            { a = append(a[:i], a[i+1:]...) }
func (a Float64S) Push(x float64)          { a = append(a, x) }
func (a Float64S) Append(x ...float64)     { a = append(a, x...) }
func (a Float64S) Pop() float64 {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a Float64S) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a Float64S) Filter(f func(i int, value interface{}) bool) Float64S {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a Float64S) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a Float64S) Map(f func(i int, value interface{}) float64) Float64S {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a Float64S) Partition(f func(i int, value interface{}) bool) (Float64S, Float64S) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a Float64S) EqualTo(b []float64) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a Float64S) Contains(b ...float64) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a Float64S) Resemble(b []float64) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a Float64S) Any(b ...float64) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a Float64S) All(b float64) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a Float64S) Frequency(b float64) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinFloat64Slice(a ...[]float64) Float64S {
	b := make(Float64S, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a Float64S) IndexOf(x float64) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type ByteS []byte

func (a ByteS) Val() []byte {
	return a
}

func (a ByteS) Copy() ByteS {
	b := make(ByteS, len(a))
	copy(b, a)
	return b
}

func (a ByteS) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = 0
	}
	a = a[:len(a)-j+i]
}

func (a ByteS) Insert(i int, x byte) { a = append(a[:i], append([]byte{x}, a[i:]...)...) }
func (a ByteS) Delete(i int)         { a = append(a[:i], a[i+1:]...) }
func (a ByteS) Push(x byte)          { a = append(a, x) }
func (a ByteS) Append(x ...byte)     { a = append(a, x...) }
func (a ByteS) Pop() byte {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a ByteS) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a ByteS) Filter(f func(i int, value interface{}) bool) ByteS {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a ByteS) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a ByteS) Map(f func(i int, value interface{}) byte) ByteS {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a ByteS) Partition(f func(i int, value interface{}) bool) (ByteS, ByteS) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a ByteS) EqualTo(b []byte) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a ByteS) Contains(b ...byte) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a ByteS) Resemble(b []byte) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a ByteS) Any(b ...byte) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a ByteS) All(b byte) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a ByteS) Frequency(b byte) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinByteSlice(a ...[]byte) ByteS {
	b := make(ByteS, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a ByteS) IndexOf(x byte) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type StringS []string

func (a StringS) Val() []string {
	return a
}

func (a StringS) Copy() StringS {
	b := make(StringS, len(a))
	copy(b, a)
	return b
}

func (a StringS) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = ""
	}
	a = a[:len(a)-j+i]
}

func (a StringS) Insert(i int, x string) { a = append(a[:i], append([]string{x}, a[i:]...)...) }
func (a StringS) Delete(i int)           { a = append(a[:i], a[i+1:]...) }
func (a StringS) Push(x string)          { a = append(a, x) }
func (a StringS) Append(x ...string)     { a = append(a, x...) }
func (a StringS) Pop() string {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a StringS) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a StringS) Filter(f func(i int, value interface{}) bool) StringS {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a StringS) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a StringS) Map(f func(i int, value interface{}) string) StringS {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a StringS) Partition(f func(i int, value interface{}) bool) (StringS, StringS) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a StringS) EqualTo(b []string) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a StringS) Contains(b ...string) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a StringS) Resemble(b []string) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a StringS) Any(b ...string) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a StringS) All(b string) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a StringS) Frequency(b string) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinStringSlice(a ...[]string) StringS {
	b := make(StringS, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a StringS) IndexOf(x string) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

type BoolS []bool

func (a BoolS) Val() []bool {
	return a
}

func (a BoolS) Copy() BoolS {
	b := make(BoolS, len(a))
	copy(b, a)
	return b
}

func (a BoolS) Cut(i int, j int) {
	copy(a[i:], a[j:])
	for k, n := len(a)-j+i, len(a); k < n; k++ {
		a[k] = false
	}
	a = a[:len(a)-j+i]
}

func (a BoolS) Insert(i int, x bool) { a = append(a[:i], append([]bool{x}, a[i:]...)...) }
func (a BoolS) Delete(i int)         { a = append(a[:i], a[i+1:]...) }
func (a BoolS) Push(x bool)          { a = append(a, x) }
func (a BoolS) Append(x ...bool)     { a = append(a, x...) }
func (a BoolS) Pop() bool {
	x := a[len(a)-1]
	a = a[:len(a)-1]
	return x
}

func (a BoolS) Reverse() {
	for i := len(a)/2 - 1; i >= 0; i-- {
		opp := len(a) - 1 - i
		a[i], a[opp] = a[opp], a[i]
	}
}

func (a BoolS) Filter(f func(i int, value interface{}) bool) BoolS {
	b := a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		}
	}
	return b
}

func (a BoolS) Each(f func(i int, value interface{})) {
	for i, v := range a {
		f(i, v)
	}
}

func (a BoolS) Map(f func(i int, value interface{}) bool) BoolS {
	b := a[:0]
	for i, v := range a {
		b = append(b, f(i, v))
	}
	return b
}

func (a BoolS) Partition(f func(i int, value interface{}) bool) (BoolS, BoolS) {
	b, c := a[:0], a[:0]
	for i, v := range a {
		if f(i, v) {
			b = append(b, v)
		} else {
			c = append(c, v)
		}
	}
	return b, c
}

func (a BoolS) EqualTo(b []bool) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if v != b[i] {
			return false
		}
	}
	return true
}

func (a BoolS) Contains(b ...bool) bool {
	if len(a) < len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				if len(b) == 0 {
					return true
				}
				continue OutLoop
			}
		}
	}
	return false
}

func (a BoolS) Resemble(b []bool) bool {
	if len(a) != len(b) {
		return false
	}
OutLoop:
	for _, v1 := range a {
		for i, v2 := range b {
			if v1 == v2 {
				b = append(b[:i], b[i+1:]...)
				continue OutLoop
			}
		}
		return false
	}
	return true
}

func (a BoolS) Any(b ...bool) bool {
	for _, v1 := range a {
		for _, v2 := range b {
			if v1 == v2 {
				return true
			}
		}
	}
	return false
}

func (a BoolS) All(b bool) bool {
	for _, v := range a {
		if v != b {
			return false
		}
	}
	return true
}

func (a BoolS) Frequency(b bool) int {
	c := 0
	for _, v := range a {
		if v == b {
			c++
		}
	}
	return c
}

func JoinBoolSlice(a ...[]bool) BoolS {
	b := make(BoolS, 0)
	for _, v := range a {
		b = append(b, v...)
	}
	return b
}

func (a BoolS) IndexOf(x bool) int {
	for i, v := range a {
		if v == x {
			return i
		}
	}
	return -1
}

// SORT

func (a IntS) Len() int           { return len(a) }
func (a IntS) Less(i, j int) bool { return a[i] < a[j] }
func (a IntS) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a IntS) Sort()              { sort.Sort(a) }
func (a IntS) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func (a Int8S) Len() int           { return len(a) }
func (a Int8S) Less(i, j int) bool { return a[i] < a[j] }
func (a Int8S) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a Int8S) Sort()              { sort.Sort(a) }
func (a Int8S) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func (a Int16S) Len() int           { return len(a) }
func (a Int16S) Less(i, j int) bool { return a[i] < a[j] }
func (a Int16S) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a Int16S) Sort()              { sort.Sort(a) }
func (a Int16S) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func (a Int32S) Len() int           { return len(a) }
func (a Int32S) Less(i, j int) bool { return a[i] < a[j] }
func (a Int32S) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a Int32S) Sort()              { sort.Sort(a) }
func (a Int32S) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func (a Int64S) Len() int           { return len(a) }
func (a Int64S) Less(i, j int) bool { return a[i] < a[j] }
func (a Int64S) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a Int64S) Sort()              { sort.Sort(a) }
func (a Int64S) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func (a Uint8S) Len() int           { return len(a) }
func (a Uint8S) Less(i, j int) bool { return a[i] < a[j] }
func (a Uint8S) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a Uint8S) Sort()              { sort.Sort(a) }
func (a Uint8S) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func (a Uint16S) Len() int           { return len(a) }
func (a Uint16S) Less(i, j int) bool { return a[i] < a[j] }
func (a Uint16S) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a Uint16S) Sort()              { sort.Sort(a) }
func (a Uint16S) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func (a Uint32S) Len() int           { return len(a) }
func (a Uint32S) Less(i, j int) bool { return a[i] < a[j] }
func (a Uint32S) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a Uint32S) Sort()              { sort.Sort(a) }
func (a Uint32S) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func (a Uint64S) Len() int           { return len(a) }
func (a Uint64S) Less(i, j int) bool { return a[i] < a[j] }
func (a Uint64S) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a Uint64S) Sort()              { sort.Sort(a) }
func (a Uint64S) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func (a ByteS) Len() int           { return len(a) }
func (a ByteS) Less(i, j int) bool { return a[i] < a[j] }
func (a ByteS) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByteS) Sort()              { sort.Sort(a) }
func (a ByteS) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func (a StringS) Len() int           { return len(a) }
func (a StringS) Less(i, j int) bool { return a[i] < a[j] }
func (a StringS) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a StringS) Sort()              { sort.Sort(a) }
func (a StringS) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func (a Float32S) Len() int           { return len(a) }
func (a Float32S) Less(i, j int) bool { return a[i] < a[j] || isNaNFloat32(a[i]) && !isNaNFloat32(a[j]) }
func (a Float32S) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a Float32S) Sort()              { sort.Sort(a) }
func (a Float32S) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func (a Float64S) Len() int           { return len(a) }
func (a Float64S) Less(i, j int) bool { return a[i] < a[j] || isNaNFloat64(a[i]) && !isNaNFloat64(a[j]) }
func (a Float64S) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a Float64S) Sort()              { sort.Sort(a) }
func (a Float64S) SortReverse()       { sort.Sort(sort.Reverse(a)) }

func isNaNFloat64(f float64) bool { return f != f }
func isNaNFloat32(f float32) bool { return f != f }

func (a Int8S) ToIntSlice() []int {
	b := make([]int, 0)
	for _, v := range a {
		b = append(b, int(v))
	}
	return b
}

func (a Int16S) ToIntSlice() []int {
	b := make([]int, 0)
	for _, v := range a {
		b = append(b, int(v))
	}
	return b
}

func (a Int32S) ToIntSlice() []int {
	b := make([]int, 0)
	for _, v := range a {
		b = append(b, int(v))
	}
	return b
}

func GreaterThan(x interface{}) func(int, interface{}) bool {
	return func(i int, v interface{}) bool {
		if err := oglematchers.GreaterThan(x).Matches(v); err != nil {
			return false
		}
		return true
	}
}

func GreaterOrEqual(x interface{}) func(int, interface{}) bool {
	return func(i int, v interface{}) bool {
		if err := oglematchers.GreaterOrEqual(x).Matches(v); err != nil {
			return false
		}
		return true
	}
}

func LessThan(x interface{}) func(int, interface{}) bool {
	return func(i int, v interface{}) bool {
		if err := oglematchers.LessThan(x).Matches(v); err != nil {
			return false
		}
		return true
	}
}

func LessOrEqual(x interface{}) func(int, interface{}) bool {
	return func(i int, v interface{}) bool {
		if err := oglematchers.LessOrEqual(x).Matches(v); err != nil {
			return false
		}
		return true
	}
}

func Contains(x interface{}) func(int, interface{}) bool {
	return func(i int, v interface{}) bool {
		if err := oglematchers.Contains(x).Matches(v); err != nil {
			return false
		}
		return true
	}
}

func Equals(x interface{}) func(int, interface{}) bool {
	return func(i int, v interface{}) bool {
		if err := oglematchers.Equals(x).Matches(v); err != nil {
			return false
		}
		return true
	}
}

func NotEqual(x interface{}) func(int, interface{}) bool {
	return func(i int, v interface{}) bool {
		if err := oglematchers.Equals(x).Matches(v); err != nil {
			return true
		}
		return false
	}
}

func HasSubstr(x interface{}) func(i int, v interface{}) bool {
	return func(i int, v interface{}) bool {
		if reflect.ValueOf(v).Kind() != reflect.String {
			return false
		}
		if err := oglematchers.HasSubstr(x.(string)).Matches(v); err != nil {
			return false
		}
		return true
	}
}

func Regexp(pattern interface{}) func(int, interface{}) bool {
	return func(i int, v interface{}) bool {
		if reflect.ValueOf(v).Kind() != reflect.String {
			return false
		}
		if err := oglematchers.MatchesRegexp(pattern.(string)).Matches(v); err != nil {
			return false
		}
		return true
	}
}

func AnyOf(filters ...func(int, interface{}) bool) func(int, interface{}) bool {
	return func(i int, v interface{}) bool {
		for _, f := range filters {
			if f(i, v) {
				return true
			}
		}
		return false
	}
}

func AllOf(filters ...func(int, interface{}) bool) func(int, interface{}) bool {
	return func(i int, v interface{}) bool {
		for _, f := range filters {
			if !f(i, v) {
				return false
			}
		}
		return true
	}
}

func main() {
	a := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	fmt.Println(a)
	fmt.Println(IntS(a).Filter(AnyOf(LessThan(3), GreaterOrEqual(7))))
}
