package main

import (
	"os"
	"text/template"
)

var tmlpStr = `package main

import (
    "fmt"
    "reflect"
    "sort"

    "github.com/jacobsa/oglematchers"
)

// AUTO GENERATED - DO NOT EDIT
// GENERATED BY tools/genutil/gen_util.go

{{range .all}}
type {{.UpperName}}S []{{.TypeName}}

func (a {{.UpperName}}S) Val() []{{.TypeName}} {
    return a
}

func (a {{.UpperName}}S) Copy() {{.UpperName}}S {
    b := make({{.UpperName}}S, len(a))
    copy(b, a)
    return b
}

func (a {{.UpperName}}S) Cut(i int, j int) {
    copy(a[i:], a[j:])
    for k, n := len(a)-j+i, len(a); k < n; k++ {
        a[k] = {{.ZeroValue}}
    }
    a = a[:len(a)-j+i]
}

func (a {{.UpperName}}S) Insert(i int, x {{.TypeName}}) { a = append(a[:i], append([]{{.TypeName}}{x}, a[i:]...)...) }
func (a {{.UpperName}}S) Delete(i int)                  { a = append(a[:i], a[i+1:]...) }
func (a {{.UpperName}}S) Push(x {{.TypeName}})          { a = append(a, x) }
func (a {{.UpperName}}S) Append(x ...{{.TypeName}})     { a = append(a, x...) }
func (a {{.UpperName}}S) Pop() {{.TypeName}} {
    x :=  a[len(a)-1]
    a = a[:len(a)-1]
    return x
}

func (a {{.UpperName}}S) Reverse() {
    for i := len(a)/2 - 1; i >= 0; i-- {
        opp := len(a) - 1 - i
        a[i], a[opp] = a[opp], a[i]
    }
}

func (a {{.UpperName}}S) Filter(f func(i int, value interface{}) bool) {{.UpperName}}S {
    b := a[:0]
    for i, v := range a {
        if f(i, v) {
            b = append(b, v)
        }
    }
    return b
}

func (a {{.UpperName}}S) Each(f func(i int, value interface{})) {
    for i, v := range a {
        f(i, v)
    }
}

func (a {{.UpperName}}S) Map(f func(i int, value interface{}) {{.TypeName}}) {{.UpperName}}S {
    b := a[:0]
    for i, v := range a {
        b = append(b, f(i, v))
    }
    return b
}

func (a {{.UpperName}}S) Partition(f func(i int, value interface{}) bool) ({{.UpperName}}S, {{.UpperName}}S) {
    b, c := a[:0], a[:0]
    for i, v := range a {
        if f(i, v) {
            b = append(b, v)
        } else {
            c = append(c, v)
        }
    }
    return b, c
}


func (a {{.UpperName}}S) EqualTo(b []{{.TypeName}}) bool {
    if len(a) != len(b) {
        return false
    }
    for i, v := range a {
        if v != b[i] {
            return false
        }
    }
    return true
}

func (a {{.UpperName}}S) Contains(b ...{{.TypeName}}) bool {
    if len(a) < len(b) {
        return false
    }
OutLoop:
    for _, v1 := range a {
        for i, v2 := range b {
            if v1 == v2 {
                b = append(b[:i], b[i+1:]...)
                if len(b) == 0 {
                    return true
                }
                continue OutLoop
            }
        }
    }
    return false
}

func (a {{.UpperName}}S) Resemble(b []{{.TypeName}}) bool {
    if len(a) != len(b) {
        return false
    }
OutLoop:
    for _, v1 := range a {
        for i, v2 := range b {
            if v1 == v2 {
                b = append(b[:i], b[i+1:]...)
                continue OutLoop
            }
        }
        return false
    }
    return true
}

func (a {{.UpperName}}S) Any(b ...{{.TypeName}}) bool {
    for _, v1 := range a {
        for _, v2 := range b {
            if v1 == v2 {
                return true
            }
        }
    }
    return false
}

func (a {{.UpperName}}S) All(b {{.TypeName}}) bool {
    for _, v := range a {
        if v != b {
            return false
        }
    }
    return true
}

func (a {{.UpperName}}S) Frequency(b {{.TypeName}}) int {
    c := 0
    for _, v := range a {
        if v == b {
            c++
        }
    }
    return c
}

func Join{{.UpperName}}Slice(a ...[]{{.TypeName}}) {{.UpperName}}S {
    b := make({{.UpperName}}S, 0)
    for _, v := range a {
        b = append(b, v...)
    }
    return b
}

func (a {{.UpperName}}S) IndexOf(x {{.TypeName}}) int {
    for i, v := range a {
        if v == x {
            return i
        }
    }
    return -1
}

{{end}}
// SORT 
{{range .ints_etc}}
func (a {{.UpperName}}S) Len() int           { return len(a) }
func (a {{.UpperName}}S) Less(i, j int) bool { return a[i] < a[j] }
func (a {{.UpperName}}S) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a {{.UpperName}}S) Sort()              { sort.Sort(a) }
func (a {{.UpperName}}S) SortReverse()       { sort.Sort(sort.Reverse(a)) }
{{end}}
{{range .floats}}
func (a {{.UpperName}}S) Len() int           { return len(a) }
func (a {{.UpperName}}S) Less(i, j int) bool { return a[i] < a[j] || isNaN{{.UpperName}}(a[i]) && !isNaN{{.UpperName}}(a[j]) }
func (a {{.UpperName}}S) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a {{.UpperName}}S) Sort()              { sort.Sort(a) }
func (a {{.UpperName}}S) SortReverse()       { sort.Sort(sort.Reverse(a)) }
{{end}}
func isNaNFloat64(f float64) bool { return f != f }
func isNaNFloat32(f float32) bool { return f != f }

func (a Int8S) ToIntSlice() []int {
    b := make([]int, 0)
    for _, v := range a {
        b = append(b, int(v))
    }
    return b
}

func (a Int16S) ToIntSlice() []int {
    b := make([]int, 0)
    for _, v := range a {
        b = append(b, int(v))
    }
    return b
}

func (a Int32S)  ToIntSlice() []int {
    b := make([]int, 0)
    for _, v := range a {
        b = append(b, int(v))
    }
    return b
}

func GreaterThan(x interface{}) func(int, interface{}) bool {
    return func(i int, v interface{}) bool {
        if err := oglematchers.GreaterThan(x).Matches(v); err != nil {
            return false
        }
        return true
    }
}

func GreaterOrEqual(x interface{}) func(int, interface{}) bool {
    return func(i int, v interface{}) bool {
        if err := oglematchers.GreaterOrEqual(x).Matches(v); err != nil {
            return false
        }
        return true
    }
}

func LessThan(x interface{}) func(int, interface{}) bool {
    return func(i int, v interface{}) bool {
        if err := oglematchers.LessThan(x).Matches(v); err != nil {
            return false
        }
        return true
    }
}

func LessOrEqual(x interface{}) func(int, interface{}) bool {
    return func(i int, v interface{}) bool {
        if err := oglematchers.LessOrEqual(x).Matches(v); err != nil {
            return false
        }
        return true
    }
}

func Contains(x interface{}) func(int, interface{}) bool {
    return func(i int, v interface{}) bool {
        if err := oglematchers.Contains(x).Matches(v); err != nil {
            return false
        }
        return true
    }
}

func Equals(x interface{}) func(int, interface{}) bool {
    return func(i int, v interface{}) bool {
        if err := oglematchers.Equals(x).Matches(v); err != nil {
            return false
        }
        return true
    }
}

func NotEqual(x interface{}) func(int, interface{}) bool {
	return func(i int, v interface{}) bool {
		if err := oglematchers.Equals(x).Matches(v); err != nil {
			return true
		}
		return false
	}
}

func HasSubstr(x interface{}) func(i int, v interface{}) bool {
    return func(i int, v interface{}) bool {
        if reflect.ValueOf(v).Kind() != reflect.String {
            return false
        }
        if err := oglematchers.HasSubstr(x.(string)).Matches(v); err != nil {
            return false
        }
        return true
    }
}

func Regexp(pattern interface{}) func(int, interface{}) bool {
    return func(i int, v interface{}) bool {
        if reflect.ValueOf(v).Kind() != reflect.String {
            return false
        }
        if err := oglematchers.MatchesRegexp(pattern.(string)).Matches(v); err != nil {
            return false
        }
        return true
    }
}

func AnyOf(filters ...func(int, interface{}) bool) func(int, interface{}) bool {
    return func(i int, v interface{}) bool {
        for _, f := range filters {
            if f(i, v) {
                return true
            }
        }
        return false
    }
}

func AllOf(filters ...func(int, interface{}) bool) func(int, interface{}) bool {
    return func(i int, v interface{}) bool {
        for _, f := range filters {
            if !f(i, v) {
                return false
            }
        }
        return true
    }
}

func main() {
    a := []int {1,2,3,4,5,6,7,8,9,10}
    fmt.Println(a)
    fmt.Println(IntS(a).Filter(AnyOf(LessThan(3), GreaterOrEqual(7))))
}
`

type Type struct {
	UpperName string
	TypeName  string
	ZeroValue string
}

func gencode() {
	tmpl, err := template.New("template").Parse(tmlpStr)
	check(err)

	file, err := os.Create("util.go")
	check(err)
	defer file.Close()

	ints := []Type{
		Type{UpperName: "Int", TypeName: "int", ZeroValue: "0"},
		Type{UpperName: "Int8", TypeName: "int8", ZeroValue: "0"},
		Type{UpperName: "Int16", TypeName: "int16", ZeroValue: "0"},
		Type{UpperName: "Int32", TypeName: "int32", ZeroValue: "0"},
		Type{UpperName: "Int64", TypeName: "int64", ZeroValue: "0"},
		Type{UpperName: "Uint8", TypeName: "uint8", ZeroValue: "0"},
		Type{UpperName: "Uint16", TypeName: "uint16", ZeroValue: "0"},
		Type{UpperName: "Uint32", TypeName: "uint32", ZeroValue: "0"},
		Type{UpperName: "Uint64", TypeName: "uint64", ZeroValue: "0"},
	}
	floats := []Type{
		Type{UpperName: "Float32", TypeName: "float32", ZeroValue: "0.0"},
		Type{UpperName: "Float64", TypeName: "float64", ZeroValue: "0.0"},
	}
	etc := []Type{
		Type{UpperName: "Byte", TypeName: "byte", ZeroValue: "0"},
		Type{UpperName: "String", TypeName: "string", ZeroValue: "\"\""},
	}
	bools := []Type{
		Type{UpperName: "Bool", TypeName: "bool", ZeroValue: "false"},
	}
	all := append(ints, floats...)
	all = append(all, etc...)
	all = append(all, bools...)
	err = tmpl.Execute(file, map[string]interface{}{
		"all":      all,
		"ints_etc": append(ints, etc...),
		"floats":   floats,
		"etc":      etc,
	})
	check(err)
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}

func main() {
	gencode()
}
